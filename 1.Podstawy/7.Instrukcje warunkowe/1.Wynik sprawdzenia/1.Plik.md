# Wynik sprawdzenia

Kiedy por贸wnujemy dwie zmienne bdce liczb wynikiem tej operacji benidzie ***Boolean*** czyli warto ***True*** lub ***False***.

```js
const a = 25;
const b = 50;

console.log(b > a); //true
console.log(b < a); //false
console.log(b === a); //false
```

```js
const result = a > b;
console.log(result); //false
```

```js
const a = 15;
const b = 25;

if (a < b) { //kod si wykona
    console.log("A jest mniejsze od B");
}
```

```js
const nr = prompt("Podaj jak liczb");
if (nr > 5) {
    console.log(`Liczba ${nr} jest wiksza od 5`);
}
```

Ostatni listing pokazuje charakterystyczn rzecz, z kt贸r nie raz bdziemy si styka w Javascript. Pod zmienn nr pobralimy liczb, kt贸r wpisze nam w okienko u偶ytkownik. Warto pobierana z takiego okienka zawsze jest w formacie tekstowym (string). Powy偶sze r贸wnanie bdzie miao wic przykadowo posta:

```js
if ("7" > 5) {
    console.log(`Liczba 7 jest wiksza od 5`);
}
```

co r贸wnoznaczne jest z tym, 偶e przyr贸wnujemy do siebie tekst z liczb.

W Javascript mo偶emy sprawdza ze sob dowolne typy danych.

W przypadku por贸wnywania string贸w dziaa tak zwane por贸wnywanie leksykograficzne (sownikowo), gdzie teksty por贸wnywane s litera po literze:

```js
console.log("ab" > "aa"); //true
console.log("pies" > "kot"); //true
console.log("abc" > "acc"); //false
console.log("alicja" > "bela"); //false
console.log("Marcin" > "Ania"); //true - znaczy lepszy
```

Przy takim por贸wnaniu string贸w brane s pod uwag pozycje liter na tablicy znak贸w Unicode. Powoduje to, 偶e "a" jest wiksze od "A", poniewa偶 znajduje si na dalszej pozycji w takiej tabeli.

```js
console.log("a" > "A"); //true
console.log("Kot" > "kot"); //false

//dlatego warto przed konwersj zr贸wna wielko liter
console.log("alicja" > "Beata"); //true
```

W przypadku por贸wnywania wartoci innych typ贸w s one konwertowane do liczb, a nastpnie por贸wnywane s te liczby:

```js
console.log("3" > 2); //true bo 3 > 2
console.log("02" > 3); //false bo 2 > 3
console.log("0" == 0); //true

console.log(true > 2); //false bo true to 1
console.log(false < 2); //true bo false to 0

console.log("Ala" > 0); //false bo konwersja "Ala" na liczb to NaN (NonANumber), a NaN jest mniejsze od ka偶dej liczby
console.log("Kot" > -Infinity); //false - to samo co powy偶ej. NaN jest mniejsze od ka偶dej liczby
```

Da si tak ale lepiej nie robi takich por贸wna.

Polecam na co dzie pisa mo偶e i nieco du偶szy, ale i bezpieczniejszy kod. Tworzc wic warunki staraj si konwertowa dane wartoci do podobnego typu.

```js
//zamiast
const nr = prompt("Podaj liczb z zakresu 1-10");
if (nr > 5) { ... }

//napisz
const nr = Number(prompt("Podaj liczb z zakresu 1-10"));
if (nr > 5) { ... }
```

Dziki manualnej konwersji unikniesz bd贸w w najmniej oczekiwanej sytuacji:

```js
const nr = prompt("Podaj liczb 10");
if (nr == 10) {
    console.log(nr + nr);
}
```

W powy偶szym kodzie w konsoli powinnimy dosta wynik 20, jednak rezultatem jest 1010. Wynika to z tego, 偶e prompt() (podobnie do kontrolek formularzy) zwraca nam dane w formacie tekstowym. Por贸wnanie z linii 2 nie sprawdza typu a tylko warto, wic "10" == 10 jest prawdziwe. Kod si wykonuje i w rezultacie dostajemy "10" + "10" co daje nam wynik "1010".

Std te偶 polecam stosowa por贸wnywanie za pomoc trzech znak贸w (=== lub !==), kt贸ry w tecie bierze pod uwag tak偶e typ danych. Dziki temu kod taki zmusza nas do jawnej konwersji danej zmiennej na odpowiedni typ:

```js
const nr = prompt("Wpisz liczb 10");
if (nr === 10) { //nic nie zobaczymy w konsoli bo "10" nie r贸wna si 10
    console.log(nr + nr);
}
```

```js
const nr = Number(prompt("Wpisz liczb 10"));
if (nr === 10) { //to zadziaa
    console.log(nr + nr); //20
}
```

Tutaj warto wspomnie, 偶e Webstorm domylnie ka偶dorazowe u偶ycie podw贸jnego por贸wnania (==) zaznacza na 偶贸to, co oznacza potencjalny problem. Je偶eli nie chcesz 偶贸tych mieci na ekranie edytora - stosuj potr贸jne por贸wnanie  . ...Z takim argumentem nie ma co dyskutowa.